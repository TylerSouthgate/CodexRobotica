#pragma config(Sensor, S2,     sonarL,         sensorSONAR)
#pragma config(Sensor, S3,     sonarR,         sensorSONAR)
#pragma config(Sensor, S4,     DIMC,           sensorI2CCustom)
#pragma config(Motor,  motorA,          mLeft,         tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorB,          mRight,        tmotorNXT, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*
 * $Id: dexterind-compass-test1.c 123 2012-11-02 16:35:15Z xander $
 */

/**
 * dexterind-compass.h provides an API for the Dexter Industries dCompass Sensor.  This program
 * demonstrates how to use that API.
 *
 * Changelog:
 * - 0.1: Initial release
 *
 * Credits:
 * - Big thanks to Dexter Industries for providing me with the hardware necessary to write and test this.
 *
 * License: You may use this code as you wish, provided you give credit where it's due.
 *
 * THIS CODE WILL ONLY WORK WITH ROBOTC VERSION 3.54 AND HIGHER.
 * Xander Soldaat (xander_at_botbench.com)
 * 07 August 2011
 * version 0.1
 */

#include "drivers/dexterind-compass.h"

task main(){

  float heading;

  eraseDisplay();

  if (!DIMCinit(DIMC))
    PlaySound(soundException);

  while (true){

		// Read the Compass
    //DIMCreadAxes(DIMC, x_val, y_val, z_val);
    heading = round(DIMCreadHeading(DIMC));

    /*
    	right - 360deg - half of that is 180! so, if heading is greater than 180 turn right else turn left until heading is with in a closer range!
    */
    while ( round(DIMCreadHeading(DIMC)) != 0 ){
    if ( round(DIMCreadHeading(DIMC)) > 180 ){
    		nxtDisplayCenteredBigTextLine(2, "%3.2f", DIMCreadHeading(DIMC) );
				if ( round(DIMCreadHeading(DIMC)) < 330 ){
    			motor[mLeft] = 50;
	  			motor[mRight] = -50;
	  		} else {
	  			motor[mLeft] = 0;
		  		motor[mRight] = 0;
	    		wait1Msec(200);


	    		while ( round(DIMCreadHeading(DIMC)) != 0 ){
		  			nxtDisplayCenteredBigTextLine(2, "%3.2f", DIMCreadHeading(DIMC) );
						motor[mLeft] = 12;
		  			motor[mRight] = -12;
		  			wait1Msec(100);
		  			motor[mLeft] = 0;
			  		motor[mRight] = 0;
		    		wait1Msec(200);
		    	}
	    	}
	  	}
	  else if ( round(DIMCreadHeading(DIMC)) < 180 ){
    		nxtDisplayCenteredBigTextLine(2, "%3.2f", DIMCreadHeading(DIMC) );
				if ( round(DIMCreadHeading(DIMC)) > 30 ){
    		motor[mLeft] = -50;
	  		motor[mRight] = 50;
	  		} else {
	  			motor[mLeft] = 0;
		  		motor[mRight] = 0;
	    		wait1Msec(200);
	    		while ( round(DIMCreadHeading(DIMC)) != 0 ){
		  			nxtDisplayCenteredBigTextLine(2, "%3.2f", DIMCreadHeading(DIMC) );
						motor[mLeft] = -12;
		  			motor[mRight] = 12;
		  			wait1Msec(100);
		  			motor[mLeft] = 0;
			  		motor[mRight] = 0;
		    		wait1Msec(200);
		    	}
	    	}
    	}
    }
   StopAllTasks();


    //else if ( heading > 0 ){
    			//motor[mLeft] = 12;
	  			//motor[mRight] = -12;
	  			//wait1Msec(100);
	  			//motor[mLeft] = 0;
		  		//motor[mRight] = 0;
	    		//wait1Msec(100);
	  		//}



    //StopAllTasks();
    //nxtDisplayTextLine(5, "%d", x_val);
		//nxtDisplayTextLine(6, "%d", y_val);
		//nxtDisplayTextLine(7, "%d", z_val);
		//wait1Msec(50);
  }
}

/*
 * $Id: dexterind-compass-test1.c 123 2012-11-02 16:35:15Z xander $
 */
