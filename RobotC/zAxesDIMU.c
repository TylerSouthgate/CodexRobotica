#pragma config(Sensor, S1,     DIMU,           sensorI2CCustomFastSkipStates)
#pragma config(Motor,  motorA,          left,          tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorB,          right,         tmotorNXT, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "drivers/dexterind-imu.h"
#include "sensorConfig/pollAxies.h"



task main(){
	eraseDisplay();
	StartTask(pAxies);
	while(true){



		//nxtDisplayCenteredTextLine(1, "X: %2.0f", xA);
  	//nxtDisplayCenteredTextLine(2, "Y: %2.0f", yA);
  	//nxtDisplayCenteredTextLine(3, "Z: %2.0f", zA);



	/*


	so if we get a reading of, say 30 how do we translate that into the top position of the elipse?

	we have a screen size of 100 X 70 pixela - 0 to 99 and 0 to 69

	29 / 100 = 0.29 (one percent of height)
	90 / 100 =  0.9 (one percent of 90 degrese)

	yA = 30

	30 / 0.9 =  33.33

	33.33 * 0.29 = 9.6657


  float screenYa = ( yA / 2 );
	float screenXa = ( xA / 2 );


	screenYa = ( ( yA / 0.9 ) * 0.29 )


	*/

	//float heightMod = ( 29 / 100 );
	//float widthMod = ( 51 / 100 );

	float screenYa = ( ( ( yA / 2 ) / 0.9 ) * 0.51 );
	float screenXa = ( ( ( xA / 2 ) / 0.9 ) * 0.29 );
	float LR = ( ( 0 + ( screenXa / 2 ) ) * 2 );
	float	BT = ( ( 0 + ( screenYa / 2 ) ) * 2 ):
	//float heightResult = ( screenYa * heightMod );
	//float widthResult = ( screenXa * widthMod );

	//nxtDisplayCenteredTextLine(1, "X: %2.2f", screenXa, " Y: %2.2f", screenYa);


  	if ( ( screenYa >= 0 ) && ( screenXa >= 0 ) ){
			//									LEFT															TOP														RIGHT												bottom

  		nxtFillEllipse( ( ( 29 + LR ) + screenXa ), ( ( 51 + BT ) - screenYa ), ( ( 69 + LR ) - screenXa ), ( ( 11 + BT ) + screenYa ));
  		nxtDrawEllipse( ( ( 29 - LR ) + screenXa ), ( ( 51 - BT ) - screenYa ), ( ( 69 - LR ) - screenXa ), ( ( 11 - BT ) + screenYa ));

  		nxtDrawLine( ( ( 29 + LR ) + screenXa ), ( 34 + BT ), ( ( 29 - LR ) + screenXa ), ( 34 - BT ) );
			nxtDrawLine( ( ( 68 + LR ) + screenXa ), ( 34 + BT ), ( ( 68 - LR ) + screenXa ), ( 34 - BT ) );



		} else {
			nxtDrawEllipse( ( ( 29 - LR ) - screenXa ), ( ( 51 - BT ) + screenYa ), ( ( 69 - LR ) + screenXa ), ( ( 11 - BT ) - screenYa ));
			nxtFillEllipse( ( ( 29 + LR ) - screenXa ), ( ( 51 + BT ) + screenYa ), ( ( 69 + LR ) + screenXa ), ( ( 11 + BT ) - screenYa ));
		}



		wait1Msec(250);
		eraseDisplay();


		if(nNxtButtonPressed == 3)
  		{
  			xA = 0;
  			yA = 0;
  			zA = 0;
  		}



	//	motor[motorA] = 25;
	//	motor[motorB] = 25;
  //	wait1Msec(4250);
	//	motor[motorA] = 0;
  //	motor[motorB] = 0;
  //	wait1Msec(2000);
  //	yA = 0;
	//	while (yA > -45){
	//		motor[motorA] = -35;
  //		motor[motorB] = 35;
  //	}
  //	motor[motorA] = 0;
  //	motor[motorB] = 0;
  //	wait1Msec(2000);
  }

  //nxtDisplayTextLine(4, "%2.0f", counts);
}
