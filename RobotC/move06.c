#pragma config(Sensor, S1,     HTMSSUMO,       sensorLightActive)
#pragma config(Sensor, S2,     us_old,         sensorSONAR)
#pragma config(Sensor, S3,     us_new,         sensorSONAR)
#pragma config(Sensor, S4,     DIMU,           sensorI2CCustomFastSkipStates)
#pragma config(Motor,  motorA,          RIGHT,         tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorB,          LEFT,          tmotorNXT, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//Drivers, API's and Configs
#include "drivers/mindsensors-sumoeyes.h"
#include "drivers/dexterind-compass.h"
#include "sensorConfig/US_NEW.h"
#include "sensorConfig/US_OLD.h"
#include "drivers/dexterind-imu.h"
#include "sensorConfig/pollAxies.h"

// Function Defs
void turnRight();
void turnHardRight();
void turnLeft();
void turnHardLeft();
void allStall();
void allGo();
void allBack();
void allStop();
void checkLevel();
//void checkLeft();
//void checkRight();
void sonarObsticalCheck(int inType);
int calcHeading(int OriginHeading);

//Global Vars
tObstacleZone zone = 0;
int blockLeft = 0;
int blockRight = 0;


//Lets Get this thing moving!
task main() {
	// Start up the two sonar sensors and their config files
	StartTask(USNEW);
	StartTask(USOLD);
  //Start up the IDMU config
	StartTask(pAxies);
	// Set Sumo to Long Range
	MSSUMOsetShortRange(HTMSSUMO);
  while(true) {
  	zone = MSSUMOreadZone(HTMSSUMO);
    // Check front IR sensor LEFT FRONT RIGHT
    switch (zone) {
      case MSSUMO_FRONT:
      	allStop();
      	break;
      case MSSUMO_LEFT:
      	turnRight();
      	break;
      case MSSUMO_RIGHT:
      	turnLeft();
      	break;
      case MSSUMO_NONE:
      	allGo();
      	break;
    }
  	// Check left and right sonar sensors for objects
   	if ((us_NewResult < 12 ) || ( us_OldResult < 12 )){
  		sonarObsticalCheck(1);
  		} else if ( ( yA > 35 ) || ( xA > 35 ) ){
  		allStall();
			wait1Msec(500);
			allBack();
			wait1Msec(1000);
			sonarObsticalCheck(3);
		//checkLevel();
  		}
  }
}

void checkLevel(){
		allStall();
		wait1Msec(500);
		allBack();
		wait1Msec(1000);
		sonarObsticalCheck(3);
}

// Start movement functions

//Go Stright
void allGo(){ motor[RIGHT] = 50; motor[LEFT] = 50; }
//Reverse
void allBack(){ motor[RIGHT] = -50; motor[LEFT] = -50; }
//Stop Motors
void allStall(){ motor[RIGHT] = 0; motor[LEFT] = 0; }
//Curve turn right
void turnRight(){ motor[RIGHT] = 25; motor[LEFT] = 75; }
//Curve turn left
void turnLeft(){ motor[RIGHT] = 75; motor[LEFT] = 25; }
//Rotate right
void turnHardRight(){ motor[RIGHT] = -50; motor[LEFT] = 50; }
//Rotate left
void turnHardLeft(){ motor[RIGHT] = 50; motor[LEFT] = -50; }
//Calcutate heading
int calcHeading(int OriginHeading){
	if ( OriginHeading < 0 ){
		OriginHeading = abs( OriginHeading );
	} else if ( OriginHeading > 360 ){
		OriginHeading = ( OriginHeading - 360);
	} else {
		OriginHeading = OriginHeading;
	}
	return OriginHeading;
}
//Left/right sonar turns, curve and hard with compas turn ratio
void sonarObsticalCheck(int inType){
	zA=0;
	nxtDisplayCenteredBigTextLine(1, "X: %d", xA);
	nxtDisplayCenteredBigTextLine(3, "Y: %d", yA);
	nxtDisplayCenteredBigTextLine(6, "Z: %d", zA);
	switch ( inType ){
		case 1:
			if ( us_NewResult < 10 ){
	    		turnRight();
	    		wait1Msec(50);
	    			if ( us_NewResult < 10 ){
	    				turnRight();
	    				wait1Msec(50);
	    			} else {
	    				turnLeft();
	    				wait1Msec(50);
	    			}
	    	}	else if ( us_OldResult < 10 ) {
	    		turnLeft();
	    		wait1Msec(50);
	    			if ( us_OldResult < 10 ) {
	    				turnLeft();
	    				wait1Msec(50);
	    			}else{
	    				turnRight();
	    				wait1Msec(50);
	    			}
	    	}
				break;
		case 2:
			if ( ( us_NewResult > 10 ) && ( us_OldResult < 10 ) ){
					do{ motor[RIGHT] = 40; motor[LEFT] = -40; }while( zA <= 75 );
	  	}	else if ( ( us_NewResult < 10 ) && ( us_OldResult > 10 ) ) {
	  			do{ motor[RIGHT] = -40; motor[LEFT] = 40; }while( zA >= -75 );
	  	} else {
	    		int whatToDo = random(100);
	    		if ( whatToDo > 50 ){
						do{ motor[RIGHT] = 40; motor[LEFT] = -40; }while( zA <= 75 );
	  			}else{
		    		zA=0;
		  			do{ motor[RIGHT] = -40; motor[LEFT] = 40; }while( zA >= -75 );
	  			}
	    }
			break;
		case 3:
			int whatToDoNow = random(100);
  		if ( whatToDoNow > 50 ){
    		do{ motor[RIGHT] = 40; motor[LEFT] = -40; }while( zA <= 75 );
			}else{
    		do{ motor[RIGHT] = -40; motor[LEFT] = 40; }while( zA >= -75 );
			}
			break;
		}
	}

void allStop(){
	allStall();
	sonarObsticalCheck(2);
}
