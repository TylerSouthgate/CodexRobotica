#pragma config(Sensor, S1,     HTMSSUMO,       sensorLightActive)
#pragma config(Sensor, S2,     us_old,         sensorSONAR)
#pragma config(Sensor, S3,     us_new,         sensorSONAR)
#pragma config(Sensor, S4,     DIMU,           sensorI2CCustomFastSkipStates)
#pragma config(Motor,  motorA,          RIGHT,         tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorB,          LEFT,          tmotorNXT, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
#include "drivers/mindsensors-sumoeyes.h"
#include "drivers/dexterind-compass.h"
#include "sensorConfig/US_NEW.h"
#include "sensorConfig/US_OLD.h"
#include "drivers/dexterind-imu.h"
#include "sensorConfig/pollAxies.h"
void turnRight();
void turnHardRight();
void turnLeft();
void turnHardLeft();
void allStall();
void allGo();
void allBack();
void allStop();
void sonarObsticalCheck(int inType);
tObstacleZone zone = 0;
task main() {
	StartTask(USNEW);
	StartTask(USOLD);
	StartTask(pAxies);
	MSSUMOsetShortRange(HTMSSUMO);
  while(true)
  	{
  		nxtDisplayCenteredBigTextLine(1, "X: %d", xA);
	  	nxtDisplayCenteredBigTextLine(3, "Y: %d", yA);
	  	nxtDisplayCenteredBigTextLine(5, "Z: %d", zA);
	  	zone = MSSUMOreadZone(HTMSSUMO);
	    switch (zone)
	    	{
		      case MSSUMO_FRONT:
		      	allStop();
		      	break;
		      case MSSUMO_LEFT:
		      	turnRight();
		      	break;
		      case MSSUMO_RIGHT:
		      	turnLeft();
		      	break;
		      case MSSUMO_NONE:
		      	allGo();
		      	break;
	    	}
	   	if ((us_NewResult < 12 ) || ( us_OldResult < 12 ))
	   		{
	  			sonarObsticalCheck(1);
	  		}
	  	if ( xA > 40 )
	  		{
		  		allStall();
					wait1Msec(500);
					allBack();
					wait1Msec(1000);
					sonarObsticalCheck(3);
	  		}
	  	if ( yA > 40 )
	  		{
		  		allStall();
					wait1Msec(500);
					allBack();
					wait1Msec(1000);
					sonarObsticalCheck(3);
	  		}
  	}
}
void allGo()
	{
		motor[RIGHT] = 50;
		motor[LEFT] = 50;
	}
void allBack()
	{
		motor[RIGHT] = -50;
		motor[LEFT] = -50;
	}
void allStall()
	{
		motor[RIGHT] = 0;
		motor[LEFT] = 0;
	}
void turnRight()
	{
		motor[RIGHT] = 25;
		motor[LEFT] = 75;
	}
void turnLeft()
	{
		motor[RIGHT] = 75;
		motor[LEFT] = 25;
	}
void turnHardRight()
	{
		motor[RIGHT] = -50;
		motor[LEFT] = 50;
	}
void turnHardLeft()
	{
		motor[RIGHT] = 50;
		motor[LEFT] = -50;
	}
void sonarObsticalCheck(int inType)
	{
	int whatToDo = random(100);
	int whatToDoNow = random(100);
	switch ( inType ){
		case 1:
			zA = 0;
			if ( us_NewResult < 10 ){
	    		do { turnRight(); } while ( us_NewResult <= 12 );
	    		do { turnLeft(); } while ( ( zA + 15 ) < 0 );
  			}	else if ( us_OldResult < 10 ) {
	    		zA = 0;
					do { turnLeft(); } while ( us_OldResult <= 12 );
	    		do { turnRight(); } while ( ( zA - 15 ) > 0 );
  			}
				break;
		case 2:
			zA=0;xA=0;yA=0;
			if ( ( us_NewResult > 10 ) && ( us_OldResult < 10 ) ){
					do{ motor[RIGHT] = 40; motor[LEFT] = -40; }while( zA <= 75 );
	  	}	else if ( ( us_NewResult < 10 ) && ( us_OldResult > 10 ) ) {
	  			do{ motor[RIGHT] = -40; motor[LEFT] = 40; }while( zA >= -75 );
	  	} else {
	    		if ( whatToDo > 50 ){
						do{ motor[RIGHT] = 40; motor[LEFT] = -40; }while( zA <= 75 );
	  			}else{
		    		do{ motor[RIGHT] = -40; motor[LEFT] = 40; }while( zA >= -75 );
	  			}
	    }
			break;
		case 3:
			zA=0;xA=0;yA=0;
			if ( whatToDoNow > 50 ){
    		do{ motor[RIGHT] = 40; motor[LEFT] = -40; }while( zA <= 75 );
			}else{
    		do{ motor[RIGHT] = -40; motor[LEFT] = 40; }while( zA >= -75 );
			}
			break;
		}
	}
void allStop()
	{
		allStall();
		sonarObsticalCheck(2);
	}
