#pragma config(Sensor, S1,     touchArm,          sensorTouch)
#pragma config(Sensor, S2,     touchClaw,         sensorTouch)
#pragma config(Motor,  motorA,          claw,          tmotorNXT, PIDControl, reversed, encoder)
#pragma config(Motor,  motorB,          arm,           tmotorNXT, PIDControl, reversed, encoder)
#pragma config(Motor,  motorC,          turntable,     tmotorNXT, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

void openClaw(int dClawOpen);

void closeClaw(int dClawClose);
void extendArm(int dExtendArm);
void retractArm(int dRetractArm);
void rotateLeft(int dRotateLeft);
void rotateRight(int dRotateRight);
int clawPosition = 0;
int armPosition = 0;
int turntablePosition = 0;


/*Open the Claw*/
void openClaw(int dClawOpen)
{
	nMotorEncoder[motorA] = 0;
	while(nMotorEncoder[motorA] < dClawOpen)
		{
			motor[motorA] = 15;
		}
	motor[motorA] = 0;
	clawPosition = nMotorEncoder[motorA];
	return;
}

void closeClaw(int dClawClose)
{
	nMotorEncoder[motorA] = 0;
	while(nMotorEncoder[motorA] > dClawClose)
		{
			motor[motorA] = -15;
			if (SensorValue[S2] == 1)
				{
				motor[motorA] = 0;
				clawPosition = nMotorEncoder[motorA];
				return;
				}
		}
	motor[motorA] = 0;
	//clawPosition = 0;
	return;
}

void extendArm(int dExtendArm)
{
	nMotorEncoder[motorB] = 0;
	while(nMotorEncoder[motorB] < dExtendArm)
		{
			motor[motorB] = 100;
			if (SensorValue[S1] == 1)
				{
				motor[motorB] = 0;
				armPosition = nMotorEncoder[motorB];
				return;
				}
		}
	motor[motorB] = 0;
	armPosition = nMotorEncoder[motorB];
	return;
}

void retractArm(int dRetractArm)
{
	nMotorEncoder[motorB] = 0;
	while(nMotorEncoder[motorB] > -dRetractArm)
		{
			motor[motorB] = -100;
		}
	motor[motorB] = 0;
	armPosition = 0;
	return;
}

void rotateLeft(int dRotateLeft)
{
	nMotorEncoder[motorC] = 0;
	while(nMotorEncoder[motorC] < dRotateLeft)
		{
			motor[motorC] = 100;
		}
	motor[motorC] = 0;
	turntablePosition = nMotorEncoder[motorC];
	return;
}

void rotateRight(int dRotateRight)
{
	nMotorEncoder[motorC] = 0;
	while(nMotorEncoder[motorC] > dRotateRight)
		{
			motor[motorC] = -100;
		}
	motor[motorC] = 0;
	turntablePosition = 0;
	return;
}


task main()
{
	openClaw(50);
	wait1Msec(1000);
	extendArm(360*28);
	wait1Msec(2000);
	closeClaw(-55);
	wait1Msec(1000);
	retractArm(armPosition);
	wait1Msec(1000);
	rotateLeft(360*20);
	wait1Msec(1000);
	extendArm(360*30);
	wait1Msec(1000);
	openClaw(50);
	wait1Msec(1000);
	retractArm(armPosition);
	wait1Msec(1000);
	closeClaw(-clawPosition);
	wait1Msec(1000);
	rotateRight(-(turntablePosition + 360));

//	extendArm(360*28);
//	wait1Msec(1000);
//	openClaw(50);
//	wait1Msec(1000);
//	retractArm(armPosition + (360*1.5));
//	wait1Msec(1000);
//	closeClaw(-clawPosition);
//	wait1Msec(1000);
//	wait1Msec(1000);
//	rotateLeft(360*20);
//	wait1Msec(1000);
//	extendArm(360*28);
//	wait1Msec(1000);
//	rotateRight(-(turntablePosition + (360*3)));
}
