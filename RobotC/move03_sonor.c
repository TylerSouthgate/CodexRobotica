#pragma config(Sensor, S1,     Tleft,          sensorTouch)
#pragma config(Sensor, S2,     TopLight,       sensorCOLORFULL)
#pragma config(Sensor, S3,     Rsonar,         sensorSONAR)
#pragma config(Sensor, S4,     Lsonar,         sensorSONAR)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

void rangeResponceRight(int inTurnRange, int inReversRange);
void rangeResponceLeft(int inTurnRange, int inReversRange);
void lowRangeResponceRight(int inReversRange);
void lowRangeResponceLeft(int inReversRange);
void touchResponceL();
void touchResponceR();
void lightResponce();

int turnCount = 0;
int fSpeed = -20;
int rSpeed = 20;

task main{
	int range = 25;
	int turnRange = ( range );
	int reverseRange = ( range - 10 );
	int senTest = 0;
	int senTest2 = 0;
	while(true){
	  SensorType[TopLight] = sensorCOLORNONE;
	  motor[motorB] = fSpeed;
		motor[motorC] = fSpeed;

		if (turnCount > 5){
			motor[motorB] = 0;
	    motor[motorC] = 0;
	    wait1Msec(200);
    	if (SensorValue[Rsonar] > SensorValue[Lsonar]){
	    	motor[motorB] = rSpeed;
	    	motor[motorC] = rSpeed;
	    	wait1Msec(400);
      	motor[motorB] = fSpeed;
      	motor[motorC] = rSpeed;
      	wait1Msec(400);
      }	else {
      	motor[motorB] = rSpeed;
	    	motor[motorC] = rSpeed;
	    	wait1Msec(400);
      	motor[motorB] = rSpeed;
      	motor[motorC] = fSpeed;
      	wait1Msec(400);
      }
      turnCount = 0;
		}

		if (SensorValue[Rsonar] < range){
		  rangeResponceRight(turnRange, reverseRange);
		}
		if (SensorValue[Lsonar] < range){
		  rangeResponceLeft(turnRange, reverseRange);
		}
		if (SensorValue[Rsonar] < reverseRange){
		  lowRangeResponceRight(reverseRange);
		}
		if (SensorValue[Lsonar] < reverseRange){
		  lowRangeResponceLeft(reverseRange);
		}
		if (SensorValue[Tleft] == 1){
			touchResponceL();
		}
		if (SensorValue[Tleft] == 1){
			touchResponceR();
		}
		turnCount=0;
  }
}

void lowRangeResponceLeft(int inReversRange){
  turnCount = ( turnCount + 1 );
  while	(SensorValue[Lsonar] < ( inReversRange ) )
    {
    	SensorType[TopLight] = sensorCOLORGREEN;
    	motor[motorB] = rSpeed;
	    motor[motorC] = rSpeed;
	    wait1Msec(400);
      motor[motorB] = rSpeed;
      motor[motorC] = fSpeed;
      wait1Msec(200);
    }
}

void lowRangeResponceRight(int inReversRange){
  turnCount = ( turnCount + 1 );
  while	(SensorValue[Rsonar] < ( inReversRange ) )
    {
    	SensorType[TopLight] = sensorCOLORGREEN;
    	motor[motorB] = rSpeed;
	    motor[motorC] = rSpeed;
	    wait1Msec(400);
      motor[motorB] = fSpeed;
      motor[motorC] = rSpeed;
      wait1Msec(200);
    }
}


void rangeResponceLeft(int inTurnRange, int inReversRange){
  turnCount = ( turnCount + 1 );
  while (SensorValue[Lsonar] < inTurnRange )
		{
		if (SensorValue[Lsonar] < inReversRange)
			{
			  lowRangeResponceLeft(inReversRange);
			} else {
					while (SensorValue[Lsonar] < inTurnRange )
						{
						  SensorType[TopLight] = sensorCOLORBLUE;
								motor[motorB] = rSpeed;
								motor[motorC] = fSpeed;
							}
				}
  }
}
void rangeResponceRight(int inTurnRange, int inReversRange){
  turnCount = ( turnCount + 1 );
  while (SensorValue[Rsonar] < inTurnRange )
		{
			if (SensorValue[Rsonar] < inReversRange)
				{
			 		lowRangeResponceRight(inReversRange);
				} else {
						while (SensorValue[Rsonar] < inTurnRange )
							{
							  SensorType[TopLight] = sensorCOLORRED;
								motor[motorB] = fSpeed;
								motor[motorC] = rSpeed;
							}
				}
  }
}

void touchResponceL(){
	turnCount = ( turnCount + 1 );
 	motor[motorB] = rSpeed;
	motor[motorC] = rSpeed;
	wait1Msec(350);
	motor[motorB] = fSpeed;
	motor[motorC] = rSpeed;
	wait1Msec(350);
}
void touchResponceR(){
	SensorType[TopLight] = sensorCOLORGREEN;
	turnCount = ( turnCount + 1 );
  motor[motorB] = rSpeed;
	motor[motorC] = rSpeed;
	wait1Msec(350);
	motor[motorB] = rSpeed;
	motor[motorC] = fSpeed;
	wait1Msec(350);

}
void lightResponce(){
	motor[motorB] = rSpeed;
	motor[motorC] = fSpeed;
	wait1Msec(350);
	motor[motorB] = fSpeed;
	motor[motorC] = fSpeed;
	wait1Msec(350);
}
